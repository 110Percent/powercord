const { randomBytes } = require('crypto');
const { instance } = require('powercord/webpack');

const getProp = (obj, path) =>
  path.length
    ? getProp(obj[path.shift()], path)
    : obj;

const injector = {
  injections: [],

  inject: (injectionId, mod, funcName, patch, pre = false) => {
    if (!mod) {
      return injector._error(`Tried to patch undefined (Injection ID "${injectionId}")`);
    }

    if (injector.injections.find(i => i.id === injectionId)) {
      return injector._error(`Injection ID "${injectionId}" is already used!`);
    }

    if (!mod.__powercordInjectionId || !mod.__powercordInjectionId[funcName]) {
      // 1st injection
      const id = randomBytes(16).toString('hex');
      mod.__powercordInjectionId = Object.assign((mod.__powercordInjectionId || {}), { [funcName]: id });
      mod[funcName] = (_oldMethod => function (...args) {
        const finalArgs = injector._runPreInjections(id, args, this);
        const returned = _oldMethod ? _oldMethod.call(this, ...finalArgs) : void 0;
        return injector._runInjections(id, finalArgs, returned, this);
      })(mod[funcName]);

      injector.injections[id] = [];
    }

    injector.injections.push({
      module: mod.__powercordInjectionId[funcName],
      id: injectionId,
      method: patch,
      pre
    });
  },

  injectRecursive: (injectionId, root, path, func, i = 0) => new Promise(resolve => {
    const node = path.shift();

    injector.inject(injectionId, getProp(root, node.path), node.prop || 'render', function (args, res) {
      if (path.length === 0) {
        func.call(this, args, res);
      } else {
        injector.uninject(injectionId);
        resolve(injector.injectRecursive(injectionId, res, path, func, i + 1));
      }

      return res;
    });
  }),

  injectInFluxContainer: (injectionId, componentName, funcName, patch) => new Promise(resolve => {
    const injections = [];
    Object.values(instance.cache).filter(m => m.exports && m.exports.$$typeof && m.exports.$$typeof.toString() === 'Symbol(react.forward_ref)').forEach((e, i) => {
      const tmpInjectionId = `tmp-${injectionId}-${i}`;
      injections.push(tmpInjectionId);
      injector.inject(tmpInjectionId, e.exports, 'render', (args, res) => { // Context: ForwardProp
        injector.uninject(tmpInjectionId);
        injector.inject(tmpInjectionId, res.type.prototype, 'render', function (args, res) { // Context: FluxContainer
          injector.uninject(tmpInjectionId);
          if (res.type && res.type.displayName && res.type.displayName.toLowerCase() === componentName.toLowerCase()) {
            injector.inject(injectionId, res.type.prototype, funcName, patch);
            injections.forEach(injection => injector.uninject(injection));
            resolve();
          }
          this.forceUpdate();
          return res;
        });
        return res;
      });
    });
  }),

  uninject: (injectionId) => {
    injector.injections = injector.injections.filter(i => i.id !== injectionId);
  },

  _runPreInjections: (modId, originArgs, _this) => {
    const injections = injector.injections.filter(i => i.module === modId && i.pre);
    if (injections.length === 0) {
      return originArgs;
    }
    return injector._runPreInjectionsRecursive(injections, originArgs, _this);
  },

  _runPreInjectionsRecursive: (injections, originalArgs, _this) => {
    const injection = injections.pop();
    injection.method.call(_this, originalArgs, (args) => {
      if (injections.length > 0) {
        return injector._runPreInjectionsRecursive(injections, args, _this);
      }
      return args;
    });
  },

  _runInjections: (modId, originArgs, originReturn, _this) => {
    let finalReturn = originReturn;
    const injections = injector.injections.filter(i => i.module === modId && !i.pre);
    injections.forEach(i => {
      try {
        finalReturn = i.method.call(_this, originArgs, finalReturn);
      } catch (e) {
        injector._error(`Failed to run injection "${i.id}"`, e);
      }
    });
    return finalReturn;
  },

  _error: (...args) => {
    console.error('%c[Powercord:Injector]', 'color: #257dd4', ...args);
  }
};

module.exports = injector;
