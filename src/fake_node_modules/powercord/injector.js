const { randomBytes } = require('crypto');
const { instance } = require('powercord/webpack');

const injector = {
  injections: [],

  inject: (injectionId, mod, funcName, patch) => {
    if (!mod) {
      return injector._error(`Tried to patch undefined (Injection ID "${injectionId}")`);
    }

    if (injector.injections.find(i => i.id === injectionId)) {
      return injector._error(`Injection ID "${injectionId}" is already used!`);
    }

    if (!mod.__powercordInjectionId || !mod.__powercordInjectionId[funcName]) {
      // 1st injection
      const id = randomBytes(16).toString('hex');
      mod.__powercordInjectionId = Object.assign((mod.__powercordInjectionId || {}), { [funcName]: id });
      mod[funcName] = (_oldMethod => function (...args) { // eslint-disable-line func-names
        const returned = _oldMethod ? _oldMethod.call(this, ...args) : void 0;
        return injector._runInjections(id, args, returned, this);
      })(mod[funcName]);

      injector.injections[id] = [];
    }

    injector.injections.push({
      module: mod.__powercordInjectionId[funcName],
      id: injectionId,
      method: patch
    });
  },

  injectInFluxContainer (injectionId, componentName, funcName, patch) {
    const injections = [];
    Object.values(instance.cache).filter(m => m.exports && m.exports.$$typeof && m.exports.$$typeof.toString() === 'Symbol(react.forward_ref)').forEach((e, i) => {
      const tmpInjectionId = `tmp-${injectionId}-${i}`;
      injections.push(tmpInjectionId);
      injector.inject(tmpInjectionId, e.exports, 'render', (args, res) => {
        injector.uninject(tmpInjectionId);
        injector.inject(tmpInjectionId, res.type.prototype, 'render', (args, res) => { // eslint-disable-line no-shadow
          injector.uninject(tmpInjectionId);
          if (res.type && res.type.displayName && res.type.displayName.toLowerCase() === componentName.toLowerCase()) {
            injector.inject(injectionId, res.type.prototype, funcName, patch);
            injections.forEach(injection => injector.uninject(injection));
          }
          return res;
        });
        return res;
      });
    });
  },

  uninject: (injectionId) => {
    injector.injections = injector.injections.filter(i => i.id !== injectionId);
  },

  _runInjections: (modId, originArgs, originReturn, _this) => {
    let finalReturn = originReturn;
    const injections = injector.injections.filter(i => i.module === modId);
    injections.forEach(i => {
      try {
        finalReturn = i.method.call(_this, originArgs, finalReturn);
      } catch (e) {
        injector._error(`Failed to run injection "${i.id}"`, e);
      }
    });
    return finalReturn;
  },

  _error: (...args) => {
    console.error('%c[Powercord:Injector]', 'color: #257dd4', ...args);
  }
};

module.exports = injector;
